import{S as e,i as t,s as n,c as a,e as r,a as o,h as i,m as s,j as c,t as d,b as m,d as l,g as p,p as $,v as h,z as f,o as g,r as u,u as y,x as w}from"./client.a317a7db.js";import"./Tag.2a2eba50.js";import"./Post-Tags-Projects.ad23e89b.js";import{P as b,a as v}from"./Post-Contents.59cb1af8.js";import{P as T}from"./Post-Section.c30131de.js";import{L as R}from"./Link-External.2f63a638.js";import{P as D}from"./PrismJS.7510f848.js";import{C as x}from"./Callout.958159b8.js";import{V as S}from"./Vimeo.4e6c857b.js";function I(e){let t,n;const r=new D({props:{language:"csharp",header:"RecordingData.cs",code:"\npublic class RecordingData\n{    \n    public float RecordedRate { get; set; }\n    private List<RecordData> recordedData = new List<RecordData>();\n\n    public struct RecordData\n    {\n        public Vector3 Position { get; set; }\n        public Quaternion Rotation { get; set; }\n    }\n\n    public void AddDataLine(RecordData data)\n    {\n        recordedData.Add(data);\n    }\n\n    public int pointer = 0;\n    public void MoveToStartOfData()\n    {\n        pointer = 0;\n    }\n\n    public RecordData? GetNextDataLine()\n    {\n        var count = recordedData.Count;\n        RecordData? data = null;\n        if (count > 0 && pointer < count && pointer >= 0) // not empty and pointer is within range and pointer not negative\n        {\n            data = recordedData[pointer];\n        }        \n        pointer++;\n        return data;\n    }\n}"}});return{c(){t=$("The first thing we need to do is to record our players movement. The easiest\r\n    thing to do seems to be to record the players position and rotation\r\n    (Transform). For this we create an object which will be used to hold the\r\n    recorded information.\r\n    "),a(r.$$.fragment)},l(e){t=h(e,"The first thing we need to do is to record our players movement. The easiest\r\n    thing to do seems to be to record the players position and rotation\r\n    (Transform). For this we create an object which will be used to hold the\r\n    recorded information.\r\n    "),o(r.$$.fragment,e)},m(e,a){c(e,t,a),s(r,e,a),n=!0},p:f,i(e){n||(d(r.$$.fragment,e),n=!0)},o(e){m(r.$$.fragment,e),n=!1},d(e){e&&p(t),l(r,e)}}}function k(e){let t,n,a,r;return{c(){t=$("This can be extended to record more information in the future (maybe\r\n    "),n=g("strong"),a=$("Scale"),r=$("\r\n    ?)")},l(e){t=h(e,"This can be extended to record more information in the future (maybe\r\n    "),n=u(e,"STRONG",{});var o=y(n);a=h(o,"Scale"),o.forEach(p),r=h(e,"\r\n    ?)")},m(e,o){c(e,t,o),c(e,n,o),w(n,a),c(e,r,o)},d(e){e&&p(t),e&&p(n),e&&p(r)}}}function P(e){let t,n,a;return{c(){t=g("strong"),n=$("DoRecording"),a=$("\r\n    can be set to false to stop recording.")},l(e){t=u(e,"STRONG",{});var r=y(t);n=h(r,"DoRecording"),r.forEach(p),a=h(e,"\r\n    can be set to false to stop recording.")},m(e,r){c(e,t,r),w(t,n),c(e,a,r)},d(e){e&&p(t),e&&p(a)}}}function L(e){let t,n,r,i,b,v,T,R,x,S,I;const k=new D({props:{language:"csharp",header:"Playback Coroutine",code:"\npublic bool DoPlayback = true;\npublic void StartPlayback()\n{\n    DoPlayback = true;\n    recordingData.MoveToStartOfData(); //Move to start of playback\n    StartCoroutine(PlaybackTimer());\n}"}}),P=new D({props:{language:"csharp",header:"Playback Loop",code:"\n//PLAYBACK LOOP\nIEnumerator PlaybackTimer()\n{\n    while (DoPlayback) // Repeat Until DoPlayback is false\n    {\n        NextSnapshot();\n        yield return new WaitForSeconds(recordingData.RecordedRate / Time.timeScale);\n    }\n}"}}),L=new D({props:{language:"csharp",header:"NextSnapshot()",code:"\nprivate RecordingData.RecordData? _desiredMoveLocation = null;\n\n//MOVE DESIRED LOCATION TO NEXT LOCATION\nprivate void NextSnapshot()\n{\n    var data = recordingData.GetNextDataLine();\n\n    if (_desiredMoveLocation.HasValue && !data.HasValue) //If we previously had move location and now we do not\n    {\n        //END OF REPLAY - YOU MAY WANT TO REMOVE THE REPLAY OBJECT FROM SCENE NOW\n    }\n    _desiredMoveLocation = data;\n}"}}),O=new D({props:{language:"csharp",header:"Move Object",code:"\npublic void Update()\n{\n    if (_desiredMoveLocation.HasValue)\n    {\n        var playbackRate = recordingData.RecordedRate;\n        var amount = Math.Abs(Time.deltaTime) / playbackRate;\n        var p = Vector3.Lerp(Transform.position, _desiredMoveLocation.Value.Position, amount);\n        var r = Quaternion.Lerp(Transform.rotation, _desiredMoveLocation.Value.Rotation, amount);\n\n        Transform.position = p;\n        Transform.rotation = r;\n    }\n}"}});return{c(){t=$("Then we just need to play this data back. Again this is done with a\r\n    coroutine.\r\n    "),a(k.$$.fragment),n=$("\r\n    This is the same as the recording loop except it calls Next SnapShot().\r\n    "),a(P.$$.fragment),r=$("\r\n    The\r\n    "),i=g("strong"),b=$("NextSnapshot"),v=$("\r\n    method simply retrieves the desired transform of the object.\r\n    "),a(L.$$.fragment),T=$("\r\n    We then move the object each update frame using the\r\n    "),R=g("strong"),x=$("Lerp"),S=$("\r\n    function (this helps keep the movement smooth).\r\n    "),a(O.$$.fragment)},l(e){t=h(e,"Then we just need to play this data back. Again this is done with a\r\n    coroutine.\r\n    "),o(k.$$.fragment,e),n=h(e,"\r\n    This is the same as the recording loop except it calls Next SnapShot().\r\n    "),o(P.$$.fragment,e),r=h(e,"\r\n    The\r\n    "),i=u(e,"STRONG",{});var a=y(i);b=h(a,"NextSnapshot"),a.forEach(p),v=h(e,"\r\n    method simply retrieves the desired transform of the object.\r\n    "),o(L.$$.fragment,e),T=h(e,"\r\n    We then move the object each update frame using the\r\n    "),R=u(e,"STRONG",{});var s=y(R);x=h(s,"Lerp"),s.forEach(p),S=h(e,"\r\n    function (this helps keep the movement smooth).\r\n    "),o(O.$$.fragment,e)},m(e,a){c(e,t,a),s(k,e,a),c(e,n,a),s(P,e,a),c(e,r,a),c(e,i,a),w(i,b),c(e,v,a),s(L,e,a),c(e,T,a),c(e,R,a),w(R,x),c(e,S,a),s(O,e,a),I=!0},p:f,i(e){I||(d(k.$$.fragment,e),d(P.$$.fragment,e),d(L.$$.fragment,e),d(O.$$.fragment,e),I=!0)},o(e){m(k.$$.fragment,e),m(P.$$.fragment,e),m(L.$$.fragment,e),m(O.$$.fragment,e),I=!1},d(e){e&&p(t),l(k,e),e&&p(n),l(P,e),e&&p(r),e&&p(i),e&&p(v),l(L,e),e&&p(T),e&&p(R),e&&p(S),l(O,e)}}}function O(e){let t,n,a,r,o;return{c(){t=$("There are many many ways of doing this. I am outlining how I did it.\r\n    "),n=g("br"),a=$("\r\n    I have simplified my implementation for the purposes of this post (to\r\n    outline roughly how it was done).\r\n    "),r=g("br"),o=$("\r\n    Any feedback or improvements are welcome :)")},l(e){t=h(e,"There are many many ways of doing this. I am outlining how I did it.\r\n    "),n=u(e,"BR",{}),a=h(e,"\r\n    I have simplified my implementation for the purposes of this post (to\r\n    outline roughly how it was done).\r\n    "),r=u(e,"BR",{}),o=h(e,"\r\n    Any feedback or improvements are welcome :)")},m(e,i){c(e,t,i),c(e,n,i),c(e,a,i),c(e,r,i),c(e,o,i)},d(e){e&&p(t),e&&p(n),e&&p(a),e&&p(r),e&&p(o)}}}function N(e){let t;return{c(){t=$("Unity3d Forum WIP post")},l(e){t=h(e,"Unity3d Forum WIP post")},m(e,n){c(e,t,n)},d(e){e&&p(t)}}}function j(e){let t,n,r,i;const f=new R({props:{href:"https://forum.unity3d.com/threads/wip-time-game-time-travel.435684/",$$slots:{default:[N]},$$scope:{ctx:e}}});return{c(){t=$("Feel free to ask me anything (I have overlooked some internal workings in\r\n    this post). I also have a\r\n    "),a(f.$$.fragment),n=$("\r\n    for this game prototype (in progress).\r\n    "),r=g("br")},l(e){t=h(e,"Feel free to ask me anything (I have overlooked some internal workings in\r\n    this post). I also have a\r\n    "),o(f.$$.fragment,e),n=h(e,"\r\n    for this game prototype (in progress).\r\n    "),r=u(e,"BR",{})},m(e,a){c(e,t,a),s(f,e,a),c(e,n,a),c(e,r,a),i=!0},p(e,t){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),f.$set(n)},i(e){i||(d(f.$$.fragment,e),i=!0)},o(e){m(f.$$.fragment,e),i=!1},d(e){e&&p(t),l(f,e),e&&p(n),e&&p(r)}}}function E(e){let t,n,a;return{c(){t=$("I have not gone into any detail on how the replay data can be saved and\r\n    loaded between games (I have implemented this in my prototype).\r\n    "),n=g("br"),a=$("\r\n    I can try and write a post outlining this if this is of interest?")},l(e){t=h(e,"I have not gone into any detail on how the replay data can be saved and\r\n    loaded between games (I have implemented this in my prototype).\r\n    "),n=u(e,"BR",{}),a=h(e,"\r\n    I can try and write a post outlining this if this is of interest?")},m(e,r){c(e,t,r),c(e,n,r),c(e,a,r)},d(e){e&&p(t),e&&p(n),e&&p(a)}}}function A(e){let t,n,f,g,u,y,w,b,v,R,N;const A=new S({props:{id:"186188380"}}),M=new T({props:{title:"Record",$$slots:{default:[I]},$$scope:{ctx:e}}}),C=new x({props:{title:"Note",$$slots:{default:[k]},$$scope:{ctx:e}}}),W=new D({props:{language:"csharp",header:"TakeSnapShot()",code:"private RecordingData recordingData = new RecordingData();\npublic void TakeSnapshot()\n{\n    var t = Transform;\n    var data = new RecordData()\n    {\n        Position = t.position,\n        Rotation = t.rotation\n    };\n    recordingData.AddDataLine(data);    \n}"}}),V=new D({props:{language:"csharp",header:"Record Coroutine",code:"\npublic bool DoRecording = true;\nvoid StartRecording()\n{\n    DoRecording = true;\n    StartCoroutine(RecordingTimer(0.05f, 0f));\n}\n\n//RECORDING LOOP\nIEnumerator RecordingTimer(float sampleRate)\n{\n    recordingData.RecordedRate = sampleRate;\n    while (DoRecording) // Repeat until DoRecording is false\n    {\n        TakeSnapshot();\n        yield return new WaitForSeconds(recordingData.RecordedRate / Time.timeScale);\n    }\n}"}}),F=new x({props:{title:"Note",$$slots:{default:[P]},$$scope:{ctx:e}}}),G=new T({props:{title:"Replay",$$slots:{default:[L]},$$scope:{ctx:e}}}),U=new x({props:{title:"This is not the only way",$$slots:{default:[O]},$$scope:{ctx:e}}}),B=new x({props:{title:"Have a question?",$$slots:{default:[j]},$$scope:{ctx:e}}}),_=new x({props:{title:"More Info?",$$slots:{default:[E]},$$scope:{ctx:e}}});return{c(){t=$("This is my current progress of a time travel puzzle game created with Unity3D\r\n  "),a(A.$$.fragment),n=$("\r\n  I will briefly outline how I implemented time travel in Unity3d. As the title\r\n  suggests, this method will be the same if you are trying to create some sort\r\n  of replay system.\r\n  "),a(M.$$.fragment),f=r(),a(C.$$.fragment),g=$("\r\n  We then need to call a method which records the data.\r\n  "),a(W.$$.fragment),u=$("\r\n  We need to call the **TakeSnapshot** method at a known interval. I have used\r\n  coroutines to ensure a consistent sample of data. In the below example we are\r\n  using **0.05 seconds** which is a rate of 20fps. This seems to offer a smooth\r\n  enough playback rate (discussed later in this article).\r\n  "),a(V.$$.fragment),y=r(),a(F.$$.fragment),w=r(),a(G.$$.fragment),b=r(),a(U.$$.fragment),v=r(),a(B.$$.fragment),R=r(),a(_.$$.fragment)},l(e){t=h(e,"This is my current progress of a time travel puzzle game created with Unity3D\r\n  "),o(A.$$.fragment,e),n=h(e,"\r\n  I will briefly outline how I implemented time travel in Unity3d. As the title\r\n  suggests, this method will be the same if you are trying to create some sort\r\n  of replay system.\r\n  "),o(M.$$.fragment,e),f=i(e),o(C.$$.fragment,e),g=h(e,"\r\n  We then need to call a method which records the data.\r\n  "),o(W.$$.fragment,e),u=h(e,"\r\n  We need to call the **TakeSnapshot** method at a known interval. I have used\r\n  coroutines to ensure a consistent sample of data. In the below example we are\r\n  using **0.05 seconds** which is a rate of 20fps. This seems to offer a smooth\r\n  enough playback rate (discussed later in this article).\r\n  "),o(V.$$.fragment,e),y=i(e),o(F.$$.fragment,e),w=i(e),o(G.$$.fragment,e),b=i(e),o(U.$$.fragment,e),v=i(e),o(B.$$.fragment,e),R=i(e),o(_.$$.fragment,e)},m(e,a){c(e,t,a),s(A,e,a),c(e,n,a),s(M,e,a),c(e,f,a),s(C,e,a),c(e,g,a),s(W,e,a),c(e,u,a),s(V,e,a),c(e,y,a),s(F,e,a),c(e,w,a),s(G,e,a),c(e,b,a),s(U,e,a),c(e,v,a),s(B,e,a),c(e,R,a),s(_,e,a),N=!0},p(e,t){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),M.$set(n);const a={};4&t&&(a.$$scope={dirty:t,ctx:e}),C.$set(a);const r={};4&t&&(r.$$scope={dirty:t,ctx:e}),F.$set(r);const o={};4&t&&(o.$$scope={dirty:t,ctx:e}),G.$set(o);const i={};4&t&&(i.$$scope={dirty:t,ctx:e}),U.$set(i);const s={};4&t&&(s.$$scope={dirty:t,ctx:e}),B.$set(s);const c={};4&t&&(c.$$scope={dirty:t,ctx:e}),_.$set(c)},i(e){N||(d(A.$$.fragment,e),d(M.$$.fragment,e),d(C.$$.fragment,e),d(W.$$.fragment,e),d(V.$$.fragment,e),d(F.$$.fragment,e),d(G.$$.fragment,e),d(U.$$.fragment,e),d(B.$$.fragment,e),d(_.$$.fragment,e),N=!0)},o(e){m(A.$$.fragment,e),m(M.$$.fragment,e),m(C.$$.fragment,e),m(W.$$.fragment,e),m(V.$$.fragment,e),m(F.$$.fragment,e),m(G.$$.fragment,e),m(U.$$.fragment,e),m(B.$$.fragment,e),m(_.$$.fragment,e),N=!1},d(e){e&&p(t),l(A,e),e&&p(n),l(M,e),e&&p(f),l(C,e),e&&p(g),l(W,e),e&&p(u),l(V,e),e&&p(y),l(F,e),e&&p(w),l(G,e),e&&p(b),l(U,e),e&&p(v),l(B,e),e&&p(R),l(_,e)}}}function M(e){let t,n;const $=new b({props:{title:C,tags:e[0],projects:e[1]}}),h=new v({props:{$$slots:{default:[A]},$$scope:{ctx:e}}});return{c(){a($.$$.fragment),t=r(),a(h.$$.fragment)},l(e){o($.$$.fragment,e),t=i(e),o(h.$$.fragment,e)},m(e,a){s($,e,a),c(e,t,a),s(h,e,a),n=!0},p(e,[t]){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),h.$set(n)},i(e){n||(d($.$$.fragment,e),d(h.$$.fragment,e),n=!0)},o(e){m($.$$.fragment,e),m(h.$$.fragment,e),n=!1},d(e){l($,e),e&&p(t),l(h,e)}}}const C="Time Game 1 - Implementing Time Travel";function W(e){return[["software","unity3d"],["Time Travel Game"]]}export default class extends e{constructor(e){super(),t(this,e,W,M,n,{})}}
