import{S as e,i as t,s as n,c as a,e as s,a as o,h as r,m as i,j as c,t as m,b as l,d as h,g as $,p as g,v as d,z as u,o as f,r as p}from"./client.bf93b2b1.js";import"./Tag.4f22bcf4.js";import"./Post-Tags-Projects.ce4bd14a.js";import{P as w,a as b}from"./Post-Contents.1e083f22.js";import{P as v}from"./Post-Section.828571c4.js";import{P as y}from"./PrismJS.92e417a9.js";import{C as j}from"./Callout.c0ac3b50.js";function T(e){let t,n,s;const r=new y({props:{language:"csharp",code:'using System;\nusing System.Reflection;\nnamespace TestUtilities\n{\n    public static class TestHelpers\n    {\n        public static object RunPrivateMethod(this object obj, string methodName, params object[] args)\n        {\n            var method = obj\n                .GetType()\n                .GetMethod(methodName, BindingFlags.NonPublic | BindingFlags.Instance);\n            if (method == null)\n            {\n                throw new ArgumentException(\n                    $"{obj.GetType()} does not contain the method {methodName}", \n                    "methodName"\n                );\n            }\n            return method.Invoke(obj, args);\n        }\n    }\n}'}}),f=new y({props:{language:"csharp",code:'var name = testObject.RunPrivateMethod("SecretInternalMethod");'}});return{c(){t=g("Need the solution in the hurry?  Here you go:\r\n  "),a(r.$$.fragment),n=g("\r\nUse it like this\r\n"),a(f.$$.fragment)},l(e){t=d(e,"Need the solution in the hurry?  Here you go:\r\n  "),o(r.$$.fragment,e),n=d(e,"\r\nUse it like this\r\n"),o(f.$$.fragment,e)},m(e,a){c(e,t,a),i(r,e,a),c(e,n,a),i(f,e,a),s=!0},p:u,i(e){s||(m(r.$$.fragment,e),m(f.$$.fragment,e),s=!0)},o(e){l(r.$$.fragment,e),l(f.$$.fragment,e),s=!1},d(e){e&&$(t),h(r,e),e&&$(n),h(f,e)}}}function R(e){let t;return{c(){t=g("Running logic inside of private method suggests that the code should be refactored (maybe moved to a helper class or a service layer).  \r\nThe fact is that sometimes we need to test existing/legacy code or for a number of reasons the logic is in a private method and we need to test it.")},l(e){t=d(e,"Running logic inside of private method suggests that the code should be refactored (maybe moved to a helper class or a service layer).  \r\nThe fact is that sometimes we need to test existing/legacy code or for a number of reasons the logic is in a private method and we need to test it.")},m(e,n){c(e,t,n)},d(e){e&&$(t)}}}function x(e){let t,n,s,r,u,w,b,v,T,x,N,P,k,B,F,S;const M=new j({props:{title:"Great, I can test my private methods.  But should I?",$$slots:{default:[R]},$$scope:{ctx:e}}}),I=new y({props:{language:"csharp",inline:"true",code:"System.Reflection"}}),A=new y({props:{language:"csharp",inline:"true",code:"RunPrivateMethod()"}}),G=new y({props:{language:"csharp",inline:"true",code:"BindingFlags.NonPublic | BindingFlags.Instance"}}),C=new y({props:{language:"csharp",inline:"true",code:"MethodInfo"}});return{c(){t=g("We have a class with some internal code that we would like to run in isolation to test that it is doing what we think it is doing.  \r\n"),n=f("br"),s=f("br"),r=g("\r\nI know there are many arguments to  be made as to whether we should be doing this.  Many will suggest that having lots of logic in a private method means that it should probably be refactored into a helper class or service layer,  \r\nwhile this is true in some cases the fact is that sometimes we have some code in a class (legacy code) and we want to test it.\r\n\r\n"),a(M.$$.fragment),u=g("\r\n\r\nThe main probelm we have is that if we make an instance of a class we just don't have access to its private stuff from the outside.  \r\nLuckily for us the "),a(I.$$.fragment),w=g(" namespace can help us get access to the private members and invoke them.\r\n\r\n"),b=f("br"),v=f("br"),T=g("\r\n\r\nThe above solution is an extension method that  allows any object to call "),a(A.$$.fragment),x=g(".\r\n"),N=f("br"),P=f("br"),k=g("\r\n\r\nThe magic happens mainly with "),a(G.$$.fragment),B=g(" \r\nwhich allows us to use reflection to get the "),a(C.$$.fragment),F=g(" for the specified private method.")},l(e){t=d(e,"We have a class with some internal code that we would like to run in isolation to test that it is doing what we think it is doing.  \r\n"),n=p(e,"BR",{}),s=p(e,"BR",{}),r=d(e,"\r\nI know there are many arguments to  be made as to whether we should be doing this.  Many will suggest that having lots of logic in a private method means that it should probably be refactored into a helper class or service layer,  \r\nwhile this is true in some cases the fact is that sometimes we have some code in a class (legacy code) and we want to test it.\r\n\r\n"),o(M.$$.fragment,e),u=d(e,"\r\n\r\nThe main probelm we have is that if we make an instance of a class we just don't have access to its private stuff from the outside.  \r\nLuckily for us the "),o(I.$$.fragment,e),w=d(e," namespace can help us get access to the private members and invoke them.\r\n\r\n"),b=p(e,"BR",{}),v=p(e,"BR",{}),T=d(e,"\r\n\r\nThe above solution is an extension method that  allows any object to call "),o(A.$$.fragment,e),x=d(e,".\r\n"),N=p(e,"BR",{}),P=p(e,"BR",{}),k=d(e,"\r\n\r\nThe magic happens mainly with "),o(G.$$.fragment,e),B=d(e," \r\nwhich allows us to use reflection to get the "),o(C.$$.fragment,e),F=d(e," for the specified private method.")},m(e,a){c(e,t,a),c(e,n,a),c(e,s,a),c(e,r,a),i(M,e,a),c(e,u,a),i(I,e,a),c(e,w,a),c(e,b,a),c(e,v,a),c(e,T,a),i(A,e,a),c(e,x,a),c(e,N,a),c(e,P,a),c(e,k,a),i(G,e,a),c(e,B,a),i(C,e,a),c(e,F,a),S=!0},p(e,t){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),M.$set(n)},i(e){S||(m(M.$$.fragment,e),m(I.$$.fragment,e),m(A.$$.fragment,e),m(G.$$.fragment,e),m(C.$$.fragment,e),S=!0)},o(e){l(M.$$.fragment,e),l(I.$$.fragment,e),l(A.$$.fragment,e),l(G.$$.fragment,e),l(C.$$.fragment,e),S=!1},d(e){e&&$(t),e&&$(n),e&&$(s),e&&$(r),h(M,e),e&&$(u),h(I,e),e&&$(w),e&&$(b),e&&$(v),e&&$(T),h(A,e),e&&$(x),e&&$(N),e&&$(P),e&&$(k),h(G,e),e&&$(B),h(C,e),e&&$(F)}}}function N(e){let t,n;const s=new y({props:{language:"csharp",code:'using FluentAssertions;\nusing Xunit;\nnamespace TestUtilities\n{\n    public class UnitTest\n    {\n        [Fact]\n        public void GetFullName__Should_Return_ConcatinatedName()\n        {\n            // ARRANGE\n            var person = new Person { FirstName = "Ace", LastName = "Rimmer" };\n            // ACT\n            var name = person.RunPrivateMethod("GetFullName"); // <-- run private method\n            // ASSERT\n            name.Should().Be("Ace Rimmer");\n        }\n    }\n    \n    // Class that contains a private method\n    public class Person\n    {\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        private string GetFullName()\n        {\n            return $"{FirstName} {LastName}";\n        }\n    }\n}'}});return{c(){t=g("The following usage example shows how this would be used in a unit test\r\n\r\n"),a(s.$$.fragment)},l(e){t=d(e,"The following usage example shows how this would be used in a unit test\r\n\r\n"),o(s.$$.fragment,e)},m(e,a){c(e,t,a),i(s,e,a),n=!0},p:u,i(e){n||(m(s.$$.fragment,e),n=!0)},o(e){l(s.$$.fragment,e),n=!1},d(e){e&&$(t),h(s,e)}}}function P(e){let t,n,g;const d=new v({props:{title:"TL;DR",$$slots:{default:[T]},$$scope:{ctx:e}}}),u=new v({props:{title:"Explanation",$$slots:{default:[x]},$$scope:{ctx:e}}}),f=new v({props:{title:"Usage",$$slots:{default:[N]},$$scope:{ctx:e}}});return{c(){a(d.$$.fragment),t=s(),a(u.$$.fragment),n=s(),a(f.$$.fragment)},l(e){o(d.$$.fragment,e),t=r(e),o(u.$$.fragment,e),n=r(e),o(f.$$.fragment,e)},m(e,a){i(d,e,a),c(e,t,a),i(u,e,a),c(e,n,a),i(f,e,a),g=!0},p(e,t){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),d.$set(n);const a={};4&t&&(a.$$scope={dirty:t,ctx:e}),u.$set(a);const s={};4&t&&(s.$$scope={dirty:t,ctx:e}),f.$set(s)},i(e){g||(m(d.$$.fragment,e),m(u.$$.fragment,e),m(f.$$.fragment,e),g=!0)},o(e){l(d.$$.fragment,e),l(u.$$.fragment,e),l(f.$$.fragment,e),g=!1},d(e){h(d,e),e&&$(t),h(u,e),e&&$(n),h(f,e)}}}function k(e){let t,n;const g=new w({props:{title:B,tags:e[0],projects:e[1]}}),d=new b({props:{$$slots:{default:[P]},$$scope:{ctx:e}}});return{c(){a(g.$$.fragment),t=s(),a(d.$$.fragment)},l(e){o(g.$$.fragment,e),t=r(e),o(d.$$.fragment,e)},m(e,a){i(g,e,a),c(e,t,a),i(d,e,a),n=!0},p(e,[t]){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),d.$set(n)},i(e){n||(m(g.$$.fragment,e),m(d.$$.fragment,e),n=!0)},o(e){l(g.$$.fragment,e),l(d.$$.fragment,e),n=!1},d(e){h(g,e),e&&$(t),h(d,e)}}}const B="Test Private Methods";function F(e){return[["unit test","c-sharp"],[]]}export default class extends e{constructor(e){super(),t(this,e,F,k,n,{})}}
