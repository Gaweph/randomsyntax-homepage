import{S as e,i as t,s as n,c as a,e as s,a as r,h as o,m as i,j as m,t as c,b as l,d as h,g,p as $,v as d,z as u,o as f,r as p}from"./client.a317a7db.js";import"./Tag.2a2eba50.js";import"./Post-Tags-Projects.ad23e89b.js";import{P as w,a as b}from"./Post-Contents.59cb1af8.js";import{P as v}from"./Post-Section.c30131de.js";import{P as y}from"./PrismJS.7510f848.js";import{C as R}from"./Callout.958159b8.js";function N(e){let t,n,s;const o=new y({props:{language:"csharp",code:'using System;\nusing System.Reflection;\nnamespace TestUtilities\n{\n    public static class TestHelpers\n    {\n        public static object RunPrivateMethod(this object obj, string methodName, params object[] args)\n        {\n            var method = obj\n                .GetType()\n                .GetMethod(methodName, BindingFlags.NonPublic | BindingFlags.Instance);\n            if (method == null)\n            {\n                throw new ArgumentException(\n                    $"{obj.GetType()} does not contain the method {methodName}", \n                    "methodName"\n                );\n            }\n            return method.Invoke(obj, args);\n        }\n    }\n}'}}),f=new y({props:{language:"csharp",code:'var res1 = testObject.RunPrivateMethod("SecretInternalMethod");\nvar res2 = testObject.RunPrivateMethod("SecretInternalMethodWithArgs", arg1, arg2);'}});return{c(){t=$("Need the solution in the hurry?  Here you go:\r\n  "),a(o.$$.fragment),n=$("\r\nUse it like this\r\n"),a(f.$$.fragment)},l(e){t=d(e,"Need the solution in the hurry?  Here you go:\r\n  "),r(o.$$.fragment,e),n=d(e,"\r\nUse it like this\r\n"),r(f.$$.fragment,e)},m(e,a){m(e,t,a),i(o,e,a),m(e,n,a),i(f,e,a),s=!0},p:u,i(e){s||(c(o.$$.fragment,e),c(f.$$.fragment,e),s=!0)},o(e){l(o.$$.fragment,e),l(f.$$.fragment,e),s=!1},d(e){e&&g(t),h(o,e),e&&g(n),h(f,e)}}}function j(e){let t;return{c(){t=$("Running logic inside of private method suggests that the code should be refactored (maybe moved to a helper class or a service layer).  \r\nThe fact is that sometimes we need to test existing/legacy code or for a number of reasons the logic is in a private method and we need to test it.")},l(e){t=d(e,"Running logic inside of private method suggests that the code should be refactored (maybe moved to a helper class or a service layer).  \r\nThe fact is that sometimes we need to test existing/legacy code or for a number of reasons the logic is in a private method and we need to test it.")},m(e,n){m(e,t,n)},d(e){e&&g(t)}}}function k(e){let t,n,s,o,u,w,b,v,N,k,x,P,T,M,F,B;const S=new R({props:{title:"Great, I can test my private methods.  But should I?",$$slots:{default:[j]},$$scope:{ctx:e}}}),G=new y({props:{language:"csharp",inline:"true",code:"System.Reflection"}}),I=new y({props:{language:"csharp",inline:"true",code:"RunPrivateMethod()"}}),A=new y({props:{language:"csharp",inline:"true",code:"BindingFlags.NonPublic | BindingFlags.Instance"}}),L=new y({props:{language:"csharp",inline:"true",code:"MethodInfo"}});return{c(){t=$("We have a class with some internal code that we would like to run in isolation to test that it is doing what we think it is doing.  \r\n"),n=f("br"),s=f("br"),o=$("\r\nI know there are many arguments to  be made as to whether we should be doing this.  Many will suggest that having lots of logic in a private method means that it should probably be refactored into a helper class or service layer,  \r\nwhile this is true in some cases the fact is that sometimes we have some code in a class (legacy code) and we want to test it.\r\n\r\n"),a(S.$$.fragment),u=$("\r\n\r\nThe main probelm we have is that if we make an instance of a class we just don't have access to its private stuff from the outside.  \r\nLuckily for us the "),a(G.$$.fragment),w=$(" namespace can help us get access to the private members and invoke them.\r\n\r\n"),b=f("br"),v=f("br"),N=$("\r\n\r\nThe above solution is an extension method that  allows any object to call "),a(I.$$.fragment),k=$(".\r\n"),x=f("br"),P=f("br"),T=$("\r\n\r\nThe magic happens mainly with "),a(A.$$.fragment),M=$(" \r\nwhich allows us to use reflection to get the "),a(L.$$.fragment),F=$(" for the specified private method.")},l(e){t=d(e,"We have a class with some internal code that we would like to run in isolation to test that it is doing what we think it is doing.  \r\n"),n=p(e,"BR",{}),s=p(e,"BR",{}),o=d(e,"\r\nI know there are many arguments to  be made as to whether we should be doing this.  Many will suggest that having lots of logic in a private method means that it should probably be refactored into a helper class or service layer,  \r\nwhile this is true in some cases the fact is that sometimes we have some code in a class (legacy code) and we want to test it.\r\n\r\n"),r(S.$$.fragment,e),u=d(e,"\r\n\r\nThe main probelm we have is that if we make an instance of a class we just don't have access to its private stuff from the outside.  \r\nLuckily for us the "),r(G.$$.fragment,e),w=d(e," namespace can help us get access to the private members and invoke them.\r\n\r\n"),b=p(e,"BR",{}),v=p(e,"BR",{}),N=d(e,"\r\n\r\nThe above solution is an extension method that  allows any object to call "),r(I.$$.fragment,e),k=d(e,".\r\n"),x=p(e,"BR",{}),P=p(e,"BR",{}),T=d(e,"\r\n\r\nThe magic happens mainly with "),r(A.$$.fragment,e),M=d(e," \r\nwhich allows us to use reflection to get the "),r(L.$$.fragment,e),F=d(e," for the specified private method.")},m(e,a){m(e,t,a),m(e,n,a),m(e,s,a),m(e,o,a),i(S,e,a),m(e,u,a),i(G,e,a),m(e,w,a),m(e,b,a),m(e,v,a),m(e,N,a),i(I,e,a),m(e,k,a),m(e,x,a),m(e,P,a),m(e,T,a),i(A,e,a),m(e,M,a),i(L,e,a),m(e,F,a),B=!0},p(e,t){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),S.$set(n)},i(e){B||(c(S.$$.fragment,e),c(G.$$.fragment,e),c(I.$$.fragment,e),c(A.$$.fragment,e),c(L.$$.fragment,e),B=!0)},o(e){l(S.$$.fragment,e),l(G.$$.fragment,e),l(I.$$.fragment,e),l(A.$$.fragment,e),l(L.$$.fragment,e),B=!1},d(e){e&&g(t),e&&g(n),e&&g(s),e&&g(o),h(S,e),e&&g(u),h(G,e),e&&g(w),e&&g(b),e&&g(v),e&&g(N),h(I,e),e&&g(k),e&&g(x),e&&g(P),e&&g(T),h(A,e),e&&g(M),h(L,e),e&&g(F)}}}function x(e){let t,n;const s=new y({props:{language:"csharp",code:'public class Person\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n\n    private string GetFullName() // <-- Private Method\n    {\n        return $"{FirstName} {LastName}";\n    }\n\n    private string GetFullNameWithNickname(string nickname) // <-- Private Method\n    {\n        return $"{FirstName} \'{nickname}\' {LastName}";\n    }\n}\n[Fact]\npublic void GetFullName__Should_Return_ExpectedResult()\n{\n    // ARRANGE\n    var test = new Person { FirstName = "Ace", LastName = "Rimmer" };\n    // ACT\n    var name = test.RunPrivateMethod("GetFullName"); // <-- name of method\n    var nickname = test.RunPrivateMethod("GetFullNameWithNickname", "what a guy!"); // <-- with args\n    // ASSERT\n    name.Should().Be("Ace Rimmer");\n    nickname.Should().Be("Ace \'what a guy!\' Rimmer");\n}'}});return{c(){t=$("The following usage example shows how this would be used in a unit test\r\n\r\n"),a(s.$$.fragment)},l(e){t=d(e,"The following usage example shows how this would be used in a unit test\r\n\r\n"),r(s.$$.fragment,e)},m(e,a){m(e,t,a),i(s,e,a),n=!0},p:u,i(e){n||(c(s.$$.fragment,e),n=!0)},o(e){l(s.$$.fragment,e),n=!1},d(e){e&&g(t),h(s,e)}}}function P(e){let t,n,$;const d=new v({props:{title:"TL;DR",$$slots:{default:[N]},$$scope:{ctx:e}}}),u=new v({props:{title:"Explanation",$$slots:{default:[k]},$$scope:{ctx:e}}}),f=new v({props:{title:"Usage",$$slots:{default:[x]},$$scope:{ctx:e}}});return{c(){a(d.$$.fragment),t=s(),a(u.$$.fragment),n=s(),a(f.$$.fragment)},l(e){r(d.$$.fragment,e),t=o(e),r(u.$$.fragment,e),n=o(e),r(f.$$.fragment,e)},m(e,a){i(d,e,a),m(e,t,a),i(u,e,a),m(e,n,a),i(f,e,a),$=!0},p(e,t){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),d.$set(n);const a={};4&t&&(a.$$scope={dirty:t,ctx:e}),u.$set(a);const s={};4&t&&(s.$$scope={dirty:t,ctx:e}),f.$set(s)},i(e){$||(c(d.$$.fragment,e),c(u.$$.fragment,e),c(f.$$.fragment,e),$=!0)},o(e){l(d.$$.fragment,e),l(u.$$.fragment,e),l(f.$$.fragment,e),$=!1},d(e){h(d,e),e&&g(t),h(u,e),e&&g(n),h(f,e)}}}function T(e){let t,n;const $=new w({props:{title:M,tags:e[0],projects:e[1]}}),d=new b({props:{$$slots:{default:[P]},$$scope:{ctx:e}}});return{c(){a($.$$.fragment),t=s(),a(d.$$.fragment)},l(e){r($.$$.fragment,e),t=o(e),r(d.$$.fragment,e)},m(e,a){i($,e,a),m(e,t,a),i(d,e,a),n=!0},p(e,[t]){const n={};4&t&&(n.$$scope={dirty:t,ctx:e}),d.$set(n)},i(e){n||(c($.$$.fragment,e),c(d.$$.fragment,e),n=!0)},o(e){l($.$$.fragment,e),l(d.$$.fragment,e),n=!1},d(e){h($,e),e&&g(t),h(d,e)}}}const M="Test Private Methods with C#";function F(e){return[["unit test","c-sharp"],[]]}export default class extends e{constructor(e){super(),t(this,e,F,T,n,{})}}
