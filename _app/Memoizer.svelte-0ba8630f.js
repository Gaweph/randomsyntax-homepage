import{S as e,i as a,s as t,m as r,q as i,u as n,v as s,w as o,x as c,l as h,o as l,f as m,d as g,k as p,t as u,c as d,b as f,p as $,e as w,g as b,n as v}from"./start-52e5428b.js";import{P as y}from"./Post-Contents.svelte-5bcd0910.js";import{P as E}from"./PrismJS.svelte-0a49518b.js";import{P as M}from"./Post-Section.svelte-f6edad48.js";import{O as z}from"./Open-In-Github.svelte-626586dc.js";import"./free-solid-svg-icons-7076105a.js";function k(e){let a,t,y,M,z,k,C,F,x,T,P,N,A,S,j,G,H,W,I,q,B,R,U,O,D,J,V,Y,K,L,Q,X,Z,_,ee,ae,te,re,ie,ne,se,oe,ce,he,le,me,ge,pe,ue,de,fe,$e,we,be,ve,ye,Ee,Me,ze,ke,Ce,Fe,xe,Te,Pe;return U=new E({props:{language:"csharp",code:'// Result will be cached for the lifetime of this application\n[Cache]\npublic string HelloWorld() => "Hello World!";\n\n// Result will be cached for 500 Milliseconds\n[Cache(500)]\npublic string HelloWorld() => "500 Millisecond Cache";\n\n// Result will be cached for 5 seconds\n[Cache(5, Time.Second)]\npublic string HelloWorld() => "5 Second Cache";\n'}}),_=new E({props:{language:"csharp",code:"Install-Package Memoizer.NETStandard\n"}}),ye=new E({props:{language:"csharp",code:"[Cache]\npublic BigInteger Fib(int n)\n{\n    if (n < 2) return n;\n    return Fib(n - 1) + Fib(n - 2);\n}\nFib(5); // 0.003s\nFib(50); // 0.003s\nFib(300); // 0.010s\nFib(1000); // 0.013s\n"}}),Ce=new E({props:{language:"csharp",code:"// Brute Force method that does not Use Memoization\npublic BigInteger Fib(int n)\n{\n    if (n < 2) return n;\n    return Fib(n - 1) + Fib(n - 2);\n}\n\nFib(5); // 0.003s\nFib(50); // 977s (16 Minutes)\nFib(300); // Come back tomorrow\nFib(1000); // Years!!\n"}}),{c(){a=p("h1"),t=u("Memoizer"),y=h(),M=p("p"),z=u("This is a quick and easy way of adding "),k=p("a"),C=u("Memoization"),F=u("/Caching to your C# project."),x=h(),T=p("p"),P=p("a"),N=p("img"),S=h(),j=p("a"),G=p("img"),W=h(),I=p("a"),q=p("img"),R=h(),r(U.$$.fragment),O=h(),D=p("p"),J=u("Calls to cached method with matching arguments will be cached meaning only the first call with a unique set or args will execute the internal code."),V=h(),Y=p("h2"),K=u("Installation"),L=h(),Q=p("p"),X=u("Add the NuGet package to your project."),Z=h(),r(_.$$.fragment),ee=h(),ae=p("h2"),te=u("Why"),re=h(),ie=p("p"),ne=p("a"),se=u("Memoization"),oe=u(" is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again."),ce=h(),he=p("h2"),le=u("Usage Example"),me=h(),ge=p("p"),pe=u("There are many use cases where it is appropriate to cache the result of a method call.  A popular use case is a method that returns the Nth "),ue=p("a"),de=u("Fibonacci"),fe=u(" number.  The time taken increases exponentially as you increase N."),$e=h(),we=p("h3"),be=u("With Caching"),ve=h(),r(ye.$$.fragment),Ee=h(),Me=p("h3"),ze=u("Without Caching"),ke=h(),r(Ce.$$.fragment),Fe=h(),xe=p("p"),Te=u("As you can see the use of Caching in this example allows us to actually work out the Fib of 1000 in neglegeable time."),this.h()},l(e){a=d(e,"H1",{id:!0});var r=f(a);t=$(r,"Memoizer"),r.forEach(g),y=l(e),M=d(e,"P",{});var n=f(M);z=$(n,"This is a quick and easy way of adding "),k=d(n,"A",{href:!0});var s=f(k);C=$(s,"Memoization"),s.forEach(g),F=$(n,"/Caching to your C# project."),n.forEach(g),x=l(e),T=d(e,"P",{});var o=f(T);P=d(o,"A",{href:!0});var c=f(P);N=d(c,"IMG",{src:!0,alt:!0}),c.forEach(g),S=l(o),j=d(o,"A",{href:!0});var h=f(j);G=d(h,"IMG",{src:!0,alt:!0}),h.forEach(g),W=l(o),I=d(o,"A",{href:!0});var m=f(I);q=d(m,"IMG",{src:!0,alt:!0}),m.forEach(g),o.forEach(g),R=l(e),i(U.$$.fragment,e),O=l(e),D=d(e,"P",{});var p=f(D);J=$(p,"Calls to cached method with matching arguments will be cached meaning only the first call with a unique set or args will execute the internal code."),p.forEach(g),V=l(e),Y=d(e,"H2",{id:!0});var u=f(Y);K=$(u,"Installation"),u.forEach(g),L=l(e),Q=d(e,"P",{});var w=f(Q);X=$(w,"Add the NuGet package to your project."),w.forEach(g),Z=l(e),i(_.$$.fragment,e),ee=l(e),ae=d(e,"H2",{id:!0});var b=f(ae);te=$(b,"Why"),b.forEach(g),re=l(e),ie=d(e,"P",{});var v=f(ie);ne=d(v,"A",{href:!0});var E=f(ne);se=$(E,"Memoization"),E.forEach(g),oe=$(v," is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again."),v.forEach(g),ce=l(e),he=d(e,"H2",{id:!0});var A=f(he);le=$(A,"Usage Example"),A.forEach(g),me=l(e),ge=d(e,"P",{});var H=f(ge);pe=$(H,"There are many use cases where it is appropriate to cache the result of a method call.  A popular use case is a method that returns the Nth "),ue=d(H,"A",{href:!0});var B=f(ue);de=$(B,"Fibonacci"),B.forEach(g),fe=$(H," number.  The time taken increases exponentially as you increase N."),H.forEach(g),$e=l(e),we=d(e,"H3",{id:!0});var Pe=f(we);be=$(Pe,"With Caching"),Pe.forEach(g),ve=l(e),i(ye.$$.fragment,e),Ee=l(e),Me=d(e,"H3",{id:!0});var Ne=f(Me);ze=$(Ne,"Without Caching"),Ne.forEach(g),ke=l(e),i(Ce.$$.fragment,e),Fe=l(e),xe=d(e,"P",{});var Ae=f(xe);Te=$(Ae,"As you can see the use of Caching in this example allows us to actually work out the Fib of 1000 in neglegeable time."),Ae.forEach(g),this.h()},h(){w(a,"id","memoizer"),w(k,"href","https://en.wikipedia.org/wiki/Memoization"),N.src!==(A="https://img.shields.io/nuget/vpre/Memoizer.NETStandard.svg")&&w(N,"src","https://img.shields.io/nuget/vpre/Memoizer.NETStandard.svg"),w(N,"alt","Version"),w(P,"href","https://www.nuget.org/packages/Memoizer.NETStandard"),G.src!==(H="https://img.shields.io/nuget/dt/Memoizer.NETStandard.svg")&&w(G,"src","https://img.shields.io/nuget/dt/Memoizer.NETStandard.svg"),w(G,"alt","Downloads"),w(j,"href","https://www.nuget.org/packages/Memoizer.NETStandard"),q.src!==(B="https://github.com/Gaweph/Memoizer/actions/workflows/pr-build-and-test.yml/badge.svg")&&w(q,"src","https://github.com/Gaweph/Memoizer/actions/workflows/pr-build-and-test.yml/badge.svg"),w(q,"alt","Test Conversion"),w(I,"href","https://github.com/Gaweph/Memoizer/actions/workflows/pr-build-and-test.yml"),w(Y,"id","installation"),w(ae,"id","why"),w(ne,"href","https://en.wikipedia.org/wiki/Memoization"),w(he,"id","usageexample"),w(ue,"href","https://en.wikipedia.org/wiki/Fibonacci"),w(we,"id","withcaching"),w(Me,"id","withoutcaching")},m(e,r){m(e,a,r),b(a,t),m(e,y,r),m(e,M,r),b(M,z),b(M,k),b(k,C),b(M,F),m(e,x,r),m(e,T,r),b(T,P),b(P,N),b(T,S),b(T,j),b(j,G),b(T,W),b(T,I),b(I,q),m(e,R,r),n(U,e,r),m(e,O,r),m(e,D,r),b(D,J),m(e,V,r),m(e,Y,r),b(Y,K),m(e,L,r),m(e,Q,r),b(Q,X),m(e,Z,r),n(_,e,r),m(e,ee,r),m(e,ae,r),b(ae,te),m(e,re,r),m(e,ie,r),b(ie,ne),b(ne,se),b(ie,oe),m(e,ce,r),m(e,he,r),b(he,le),m(e,me,r),m(e,ge,r),b(ge,pe),b(ge,ue),b(ue,de),b(ge,fe),m(e,$e,r),m(e,we,r),b(we,be),m(e,ve,r),n(ye,e,r),m(e,Ee,r),m(e,Me,r),b(Me,ze),m(e,ke,r),n(Ce,e,r),m(e,Fe,r),m(e,xe,r),b(xe,Te),Pe=!0},p:v,i(e){Pe||(s(U.$$.fragment,e),s(_.$$.fragment,e),s(ye.$$.fragment,e),s(Ce.$$.fragment,e),Pe=!0)},o(e){o(U.$$.fragment,e),o(_.$$.fragment,e),o(ye.$$.fragment,e),o(Ce.$$.fragment,e),Pe=!1},d(e){e&&g(a),e&&g(y),e&&g(M),e&&g(x),e&&g(T),e&&g(R),c(U,e),e&&g(O),e&&g(D),e&&g(V),e&&g(Y),e&&g(L),e&&g(Q),e&&g(Z),c(_,e),e&&g(ee),e&&g(ae),e&&g(re),e&&g(ie),e&&g(ce),e&&g(he),e&&g(me),e&&g(ge),e&&g($e),e&&g(we),e&&g(ve),c(ye,e),e&&g(Ee),e&&g(Me),e&&g(ke),c(Ce,e),e&&g(Fe),e&&g(xe)}}}function C(e){let a,t,p,u;return a=new z({props:{url:"https://github.com/Gaweph/Memoizer"}}),p=new M({props:{$$slots:{default:[k]},$$scope:{ctx:e}}}),{c(){r(a.$$.fragment),t=h(),r(p.$$.fragment)},l(e){i(a.$$.fragment,e),t=l(e),i(p.$$.fragment,e)},m(e,r){n(a,e,r),m(e,t,r),n(p,e,r),u=!0},p(e,a){const t={};4&a&&(t.$$scope={dirty:a,ctx:e}),p.$set(t)},i(e){u||(s(a.$$.fragment,e),s(p.$$.fragment,e),u=!0)},o(e){o(a.$$.fragment,e),o(p.$$.fragment,e),u=!1},d(e){c(a,e),e&&g(t),c(p,e)}}}function F(e){let a,t;return a=new y({props:{$$slots:{default:[C]},$$scope:{ctx:e}}}),{c(){r(a.$$.fragment)},l(e){i(a.$$.fragment,e)},m(e,r){n(a,e,r),t=!0},p(e,[t]){const r={};4&t&&(r.$$scope={dirty:t,ctx:e}),a.$set(r)},i(e){t||(s(a.$$.fragment,e),t=!0)},o(e){o(a.$$.fragment,e),t=!1},d(e){c(a,e)}}}function x(e){return[]}export default class extends e{constructor(e){super(),a(this,e,x,F,t,{})}}
//# sourceMappingURL=Memoizer.svelte-0ba8630f.js.map
